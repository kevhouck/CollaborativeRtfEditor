# CollaborativeRtfEditor
A real-time collaborative rich text editor

## How does it work?
The core functionality of this application is to allow multiple users to work on a rich text format document at the same time. The library used to display the doc is Quill.js. Quill.js works by creating a delta for every change. This delta is then sent to the server to be applied to the every other connected client. A delta represents a change in the doc, and does not contain information about the entire doc. The process of sending deltas to multiple clients can lead to race conditions and clients becoming out of sync with one another. The study of this problem calls it an operational transformation. To avoid complicating this project, I use a method for resolving deltas among clients with a 3-tier architecture. Each client has their own representation of the document. When a client makes a change to the docuemnt, a delta is generated. This delta is optimistically applied to the clients document, and then is sent to the server. The server then broadcasts the delta to each client, including the client that sent it the delta. Every other client then applies the delta to their own document, and every client is in sync. So what if multiple clients optimistically update their documents, and a race condition is created? The way this is resolved is that the server will broadcast every delta in the order it receives them. If a client sends a delta, it must receive its own delta back from the server as the next delta. If it does not, then it will roll back its optimistic delta, and apply the delta it has received. This can be extended to many deltas being sent before any deltas are received.

### Assumptions
The above algorithm for keeping clients in sync relies on the assumption that every delta is sent to the client in the order the server receives them. The important part of this is that it ensures every client applies updates in the exact same way. This means that once every client has received all deltas, every client will be in the same state. This implies that this algorithm would only work in a TCP-style networking environment. This application usings socket.io, whihc in turn using WebSockets and long-polling, but order is preserved.
